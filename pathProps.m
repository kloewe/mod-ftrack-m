function props = pathProps(p,propname,varargin)
%PATHPROPS Get path properties.
%
%   R = PATHPROPS(P,PROPNAME) returns in R the property specified by
%   PROPNAME for each of the paths in P, where P is a structure as
%   generated by FTRACK. The available properties are:
%
%      Property
%      --------
%      'Coords'      World coordinates.
%
%      'Length'      Path length (in mm).
%
%      'Subscripts'  3D array subscripts, i.e., voxel coordinates.
%
%      'Points'      Number of voxels.
%
%   In case of the property 'Coords' an affine transformation matrix A can
%   additionally be specified using PATHPROPS(P,'Coord',A).
%
%   See also: FILTPATHS, READPATHS, WRITEPATHS, FTRACK.
%
%   Author: Kristian Loewe

assert(nargin == 2 || nargin == 3, 'Unexpected number of input arguments.');

assert(isstruct(p));
assert(all(isfield(p, {'paths','dims','vsiz'})));
assert(iscell(p.paths));
assert(isnumeric(p.dims) && numel(p.dims) == 3);
assert(isnumeric(p.vsiz) && numel(p.vsiz) == 3);

assert(ischar(propname), 'Property name must be of type char.');

np = numel(p.paths);

switch propname

  case 'Subscripts'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    if 0
      props = cell(np, 1);
      for i = 1:np
        [x,y,z] = ind2sub(p.dims, single(p.paths{i}));
        props{i} = int32([x y z])';
      end
    else
      props = mxPathPropsSubscripts(p.paths, int32(p.dims));
    end

  case 'Coords'
    if nargin == 3
      props = pathProps(p, 'Coords');
      A = varargin{1};
      assert(isequal(size(A), [4 4]));
      props = applyAffineTransform(props, A);
    else
      subs = pathProps(p, 'Subscripts');
      props = cellfun(@single, subs, 'UniformOutput', false);
    end

  case 'Length'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    coords = pathProps(p, 'Coords');
    if 0
      props = zeros(np, 1, 'single');
      for i = 1:np
        for j = 2:numel(p.paths{i});
          % d = norm(coords{i}(:,j-1) - coords{i}(:,j), 2);
          d = sqrt(sum((coords{i}(:,j-1) - coords{i}(:,j)).^2));
          props(i) = props(i) + d;
        end
      end
    else
      props = mxPathPropsLength(coords);
    end

  case 'Length2'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    props = cell(np, 1);
    for i = 1:np
      nvox = numel(p.paths{i});
      props{i} = zeros(nvox, 1, 'single');
      if nvox <= 1
        continue;
      end
      [x,y,z] = ind2sub(p.dims, double(p.paths{i}));
      for j = 2:nvox
        c1 = [x(j-1); y(j-1); z(j-1)];
        c2 = [x(j);   y(j);   z(j)];
        d = norm(c1.*p.vsiz(:) - c2.*p.vsiz(:), 2);
        % d = sqrt(sum((c1.*p.vsiz(:) - c2.*p.vsiz(:)).^2));
        props{i}(j) = props{i}(j-1) + d;
      end
    end

  case 'Points'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    props = cellfun('length', p.paths);

  otherwise
    error('Unexpected property name.');
end

end
