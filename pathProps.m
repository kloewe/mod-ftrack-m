function props = pathProps(p,propname,varargin)
%PATHPROPS Get path properties.
%
%   R = PATHPROPS(P,PROPNAME) returns in R the property specified by
%   PROPNAME for each of the paths in P, where P is a structure as
%   generated by FTRACK. The available properties are:
%
%      Property
%      --------
%      'Coords'      World coordinates.
%
%      'Length'      Path length (in mm).
%
%      'Subscripts'  3D array subscripts, i.e., voxel coordinates.
%
%      'Points'      Number of voxels.
%
%   In case of the property 'Coords' an affine transformation matrix A can
%   additionally be specified using PATHPROPS(P,'Coord',A).
%
%   See also: FILTPATHS, READPATHS, WRITEPATHS, FTRACK.
%
%   Author: Kristian Loewe

assert(nargin == 2 || nargin == 3, 'Unexpected number of input arguments.');

assert(isstruct(p));
assert(all(isfield(p, {'paths','dims','vsiz'})));
assert(iscell(p.paths));
assert(isnumeric(p.dims) && numel(p.dims) == 3);
assert(isnumeric(p.vsiz) && numel(p.vsiz) == 3);

assert(ischar(propname), 'Property name must be of type char.');

np = numel(p.paths);

switch propname

  case 'Subscripts'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    if 0
      props = cell(np, 1);
      for i = 1:np
        [x,y,z] = ind2sub(p.dims, single(p.paths{i}));
        props{i} = int32([x y z])';
      end
    else
      props = mxPathPropsSubscripts(p.paths, int32(p.dims));
    end

  case 'Coords'
    props = cell(np, 1);
    subs = pathProps(p, 'Subscripts');
    if nargin == 3
      A = varargin{1};
      assert(numel(A) == 16);
      assert(isequal(abs(diag(A(1:3, 1:3))), p.vsiz(:)));
      for i = 1:np;
        nvox = numel(p.paths{i});
        props{i} = zeros(3, nvox, 'single');
        for j = 1:nvox
          x0 = single(subs{i}(1,j));
          y0 = single(subs{i}(2,j));
          z0 = single(subs{i}(3,j));
          props{i}(1,j) = single(A(1,1)*x0 + A(1,2)*y0 + A(1,3)*z0 + A(1,4));
          props{i}(2,j) = single(A(2,1)*x0 + A(2,2)*y0 + A(2,3)*z0 + A(2,4));
          props{i}(3,j) = single(A(3,1)*x0 + A(3,2)*y0 + A(3,3)*z0 + A(3,4));
        end
      end
    else
      for i = 1:np
        s = single(subs{i});
        props{i} ...
          = single([s(1,:).*p.vsiz(1); s(2,:).*p.vsiz(2); s(3,:).*p.vsiz(3)]);
      end
    end

  case 'Length'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    coords = pathProps(p, 'Coords');
    if 0
      props = zeros(np, 1, 'single');
      for i = 1:np
        for j = 2:numel(p.paths{i});
          % d = norm(coords{i}(:,j-1) - coords{i}(:,j), 2);
          d = sqrt(sum((coords{i}(:,j-1) - coords{i}(:,j)).^2));
          props(i) = props(i) + d;
        end
      end
    else
      props = mxPathPropsLength(coords);
    end

  case 'Length2'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    props = cell(np, 1);
    for i = 1:np
      nvox = numel(p.paths{i});
      props{i} = zeros(nvox, 1, 'single');
      if nvox <= 1
        continue;
      end
      [x,y,z] = ind2sub(p.dims, double(p.paths{i}));
      for j = 2:nvox
        c1 = [x(j-1); y(j-1); z(j-1)];
        c2 = [x(j);   y(j);   z(j)];
        d = norm(c1.*p.vsiz(:) - c2.*p.vsiz(:), 2);
        % d = sqrt(sum((c1.*p.vsiz(:) - c2.*p.vsiz(:)).^2));
        props{i}(j) = props{i}(j-1) + d;
      end
    end

  case 'Points'
    assert(nargin == 2, 'Unexpected number of input arguments.');
    props = cellfun('length', p.paths);

  otherwise
    error('Unexpected property name.');
end

end
