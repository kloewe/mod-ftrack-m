function res = clustPaths(p,varargin)
%CLUSTPATHS Cluster paths using Joern's algorithm (revised implementation).
%
%   CL = CLUSTPATHS(P) clusters the paths in P using a revised implementation
%   of Joern's algorithm. P is a structure as generated by FTRACK. The results
%   are returned in the structure CL with the following fields:
%
%      Field            Value
%      -----            -----
%      'centroids'      Cell array of coordinates (each cell represents one
%                       cluster and contains the 3D coordinates of the
%                       corresponding centroid path). 
%
%      'support'        A numerical array containing for each cluster the
%                       number of supporting paths (= the number of members).
%
%      'mapping'        An array containing the path-to-cluster mapping, i.e.,
%                       the array contains for each path the number of the
%                       cluster that path was assigned to or 0 (for those
%                       paths that are not part of any returned cluster due
%                       to the 'MinClusterSize' parameter (see below)).
%
%   CL = CLUSTPATHS(CIN) specifies the input paths using the cell array of
%   coordinates CIN (each cell contains the 3D coordinates of one path).
%
%   CL = CLUSTPATHS(T) specifies the input paths using T, a structure of the
%   kind returned by READ_MRTRIX_TRACKS. READ_MRTRIX_TRACKS is part of the
%   MRtrix3 software package (http://www.mrtrix.org).
%
%   CL = CLUSTPATHS(...,'PARAM1',VAL1,'PARAM2',VAL2,...) can be used to
%   specify additional parameters and their values:
%
%      Parameter        Value
%      ---------        -----
%      'NumCmpPoints'   Number of comparison points at which the distance of
%                       two paths is evaluated in addition to their start and
%                       end points.
%
%      'MaxDistance'    Maximal euclidian distance between two comparison
%                       points in mm.
%
%      'MaxLengthDiff'  Maximal abs. length difference between a path and the
%                       current cluster centroid relative to the length of
%                       the centroid path.
%
%      'MinClusterSize' Minimal number of paths per cluster. Clusters with
%                       less members will not be included in the output.
%
%   Example:
%   p = readPaths('paths.dat');                 % read paths from dat-file
%   p = filtPaths(p, ...);                      % filter them (optional)
%   p = smoothPaths(p);                         % smooth them (optional)
%   h = readImgHdr('image.nii.gz');             % get appropriate header
%   c = applyAffineTransform(p, h.mat);         % apply transform -> coords
%   cl = clustPaths(c, ...);                    % cluster based on the coords
%   exportPaths(cl.centroids, 'tracks.tck');    % export to tck-file
%
%   See also: READPATHS, FILTPATHS, SMOOTHPATHS, READIMGHDR,
%   APPLYAFFINETRANSFORM, EXPORTPATHS, FTRACK.
%
%   Authors: Kristian Loewe, Joern Kaufmann

%% parse arguments
assert((nargin >= 3) && (mod(numel(varargin),2) == 0));
assert(nargout <= 1);

% get coordinates
if isstruct(p)
  if all(isfield(p, {'paths','dims','vsiz'}))
    coords = pathProps(p, 'Coords');           % input: ftrack format
  elseif all(isfield(p, {'datatype','count','data'}))
    coords = p.data;                           % input: mrtrix format
  end
elseif iscell(p)
  assert(all(cellfun(@isnumeric, p)));         % input: cell array of coords
  coords = p;
else
  error('Unexpected input argument.');
end
assert(iscell(coords));

if isempty(coords)
  return
end

fmt = 1; % format (of the coords of each path/track): 1 -> n x 3;  2 -> 3 x n

% transpose coords if necessary
assert(all(cellfun(@(c) any(size(c) == 3), coords)));
idx = find(cellfun(@(c) sum(size(c) ~= 3), coords), 1);
fmt = find(size(coords{idx}) ~= 3);
if fmt == 2
  coords = cellfun(@(c) c', coords, 'UniformOutput', false);
end

% total number of paths
nPaths = numel(coords);

% max number of points in any path
maxNumPts = max(cellfun(@(c) size(c,1), coords));

%% parse optional arguments

% defaults
nCmpPts = round(maxNumPts/10);
maxDist = 5;
maxLenDiff = 0.2;
minClustSize = 3;

for i = 1:2:numel(varargin)
  pn = varargin{i};   % parameter name
  assert(ischar(pn), 'Parameter names must be of type char.');
  pv = varargin{i+1}; % parameter value
  switch pn
    case 'NumCmpPoints'
      assert(isscalar(pv) && isnumeric(pv));
      nCmpPts = pv;
    case 'MaxDistance'
      assert(isscalar(pv) && isnumeric(pv));
      maxDist = pv;
    case 'MaxLengthDiff'
      assert(isscalar(pv) && isnumeric(pv));
      maxLenDiff = pv;
    case 'MinClusterSize'
      assert(isscalar(pv) && isnumeric(pv));
      minClustSize = pv;
    otherwise
      error('Unexpected parameter name.');
  end
end


%%
centroids = cell(nPaths,1);         % cluster centroids
nPathsPerClust = zeros(...          % number of paths per cluster
  nPaths, 1, 'single');
path2clustMap = zeros(...           % path-to-cluster mapping
  maxNumPts, 1, 'single');
nClust = 1;

centroids{1} = coords{1};           % initialize first cluster
nPathsPerClust(1) = 1;              % set path count of cluster #1
path2clustMap(1) = 1;               % assign path #1 to cluster #1

for iP = 2:nPaths
  found = false;
  for iC = 1:nClust
    
    cc = centroids{iC};             % get current cluster centroid
    cp = coords{iP};                % get current path
    
    lenClust = size(cc,1);          % length of current centroid (#coords)
    lenPath = size(cp,1);           % length of current path     (#coords)
    
    distS ...                       % distance of start points
      = sqrt(sum((cc(1,:) - cp(1,:)).^2));
    distE ...                       % distance of end points
      = sqrt(sum((cc(lenClust,:) - cp(lenPath,:)).^2));
    
    if (distS > maxDist) || (distE > maxDist)
      continue
    end
    
    lenDiff = abs(lenClust-lenPath)/lenClust; % rel. abs. length difference
    if lenDiff > maxLenDiff         % check maxLenDiff
      continue
    end
    
    if lenDiff > 0                  % adjust length (#coords)
      lengthRatio = lenClust/lenPath;
      among1 = round(lengthRatio*(1:lenPath));
      currPathOrig = cp;
      if lengthRatio <= 1           % if lenClust <= lenPath
        remInd = ...                %   remove voxels from current path
          among1(1:lenPath-1) == among1(2:lenPath);
        cp(remInd,:) = [];
      else                          % else (lenClust > lenPath)
        insInd = ...                %   insert new voxels into current path
          find((among1(2:lenPath)-among1(1:lenPath-1)) > 1);
        new_vox = (cp(insInd,:) + cp(insInd+1,:))/2;
        insInd = [0 insInd];
        cp = [];
        for s = 1:size(new_vox,1)
          cp = [cp; currPathOrig(insInd(s)+1:insInd(s+1),:); new_vox(s,:)];
        end;
        cp = [cp; currPathOrig(insInd(s+1)+1:end,:)];
      end
      lenPath = size(cp,1);         % update current path length variable
      assert(lenPath == lenClust);
    end
    
    lenSeg = floor(lenPath/(nCmpPts+1)); % segment length
    if lenSeg < 0
      lenSeg = 1;
    end

    cpts = lenSeg:lenSeg:nCmpPts*lenSeg;
    assert(numel(cpts) == nCmpPts);
    crit = false(nCmpPts,1);
    for iCP = 1:nCmpPts
      crit(iCP) = sqrt(sum((cc(cpts(iCP),:) - cp(cpts(iCP),:)).^2)) < maxDist;
    end
    
    if all(crit)                    % update centroid
      centroids{iC} = (nPathsPerClust(iC).*cc + cp)./(nPathsPerClust(iC)+1);
      nPathsPerClust(iC) = nPathsPerClust(iC) + 1;
      path2clustMap(iP) = iC;
      found = true;
      break;
    end
  end
  
  if ~found                         % create new cluster
    nClust = nClust + 1;
    centroids{nClust} = coords{iP};
    nPathsPerClust(nClust) = 1;
    path2clustMap(iP) = nClust;
  end
end

centroids = centroids(1:nClust);
nPathsPerClust = nPathsPerClust(1:nClust);

keepInd = nPathsPerClust >= minClustSize;
centroids = centroids(keepInd);
nPathsPerClust = nPathsPerClust(keepInd);
path2clustMap(~ismember(path2clustMap, find(keepInd))) = 0;
assert(sum(nPathsPerClust) == sum(path2clustMap > 0));

% revert transpose if necessary
if fmt == 2
  centroids = cellfun(@(c) c', centroids, 'UniformOutput', false);
end

% output struct
res = struct;
res.centroids = centroids;
res.support = nPathsPerClust;
res.mapping = path2clustMap;

end
