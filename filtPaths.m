function p = filtPaths(p,varargin)
%FILTPATHS Filter paths.
%
%   PR = FILTPATHS(P,'PARAM1',VAL1,'PARAM2',VAL2,...) filters the paths in
%   P and returns the remaining paths in PR, where P and PR are structures
%   as generated by FTRACK. The following parameter-value pairs are used to
%   specify the filtering criteria:
%
%      Parameter             Value
%      ---------             -----
%      'InclusionRoi'        Inclusion region.
%                            Discard paths that don't pass through the
%                            specified region.
%
%      'InclusionRoiMode'    Inclusion region mode.
%                            'all'
%                            'any'
%                            'order'
%
%      'ExclusionRoi'        Exclusion region.
%                            Discard paths that pass through the specified
%                            region.
%
%      'TerminationRoi'      Termination region.
%                            Truncate paths upon entering (or exiting) the
%                            specified region (for the first/last time). See
%                            'TerminationRoiMode'.
%
%      'TerminationRoiMode'  Termination region mode.
%                            'first-enter'  Truncate upon first entering.
%                                           The last point in a truncated
%                                           path is its first point inside
%                                           the termination ROI.
%
%                            'first-exit'   Truncate upon first exiting.
%                                           The last point in a truncated
%                                           path is the last point in its
%                                           first segment intersecting the
%                                           termination ROI.
%
%                            'last-enter'   Truncate upon last entering.
%                                           The last point in a truncated
%                                           path is the last point in its
%                                           last segment intersecting the
%                                           termination ROI.
%
%                            'last-exit'    Truncate upon last exiting.
%                                           The last point in a truncated
%                                           path is its last point inside
%                                           the termination ROI.
%
%      'MinPoints'           Minimum number of points.
%                            Discard paths with less points than the
%                            specified value.
%
%      'MaxPoints'           Maximum number of points.
%                            Discard paths with more points than the
%                            specified value.
%
%      'MinLength'           Minimum path length (in mm).
%                            Discard paths shorter than the specified value.
%
%      'MaxLength'           Maximum path length (in mm).
%                            Discard paths longer than the specified value.
%
%   Example:
%      p = struct;
%      p.dims = [3 3 3];
%      p.vsiz = [2 2 2];
%      p.paths = {[1 14 27], [1 13 26], [1 13 27], [1 14 26], [1 27 14]};
%      p.paths = cellfun(@int32, p.paths, 'UniformOutput', false);
%
%      >> p1 = filtPaths(p, 'InclusionRoi', wp1)
%      p1 =
%           dims: [3 3 3]
%           vsiz: [2 2 2]
%          paths: {[1 14 27]  [1 14 26]}
%
%      >> p2 = filtPaths(p, 'InclusionRoi', wp2)
%      p2 =
%           dims: [3 3 3]
%           vsiz: [2 2 2]
%          paths: {[1 14 27]  [1 13 27]}
%
%      >> p12all = filtPaths(p, 'InclusionRoi', wp1, 'InclusionRoi', wp2)
%      p12all =
%          dims: [3 3 3]
%          vsiz: [2 2 2]
%         paths: {[1 14 27]  [1 27 14]}
%
%      >> p12order = filtPaths(p, ...
%         'InclusionRoi', wp1, 'InclusionRoi', wp2, ...
%         'InclusionRoiMode', 'order')
%      p12order =
%          dims: [3 3 3]
%          vsiz: [2 2 2]
%         paths: {[1 14 27]}
%
%   See also: PATHPROPS, READPATHS, WRITEPATHS, FTRACK.
%
%   Author: Kristian Loewe

%% defaults
inclRoi = cell(0);
inclRoiMode = 'all';
exclRoi = [];
termRoi = [];
termRoiMode = 'first-enter';
minPoints = [];
maxPoints = [];
minLength = [];
maxLength = [];


%% parse arguments
assert((nargin >= 3) && (mod(numel(varargin),2) == 0));
assert(nargout <= 1);

assert(isstruct(p));
assert(all(isfield(p, {'paths','dims','vsiz'})));
assert(iscell(p.paths));
assert(isnumeric(p.dims) && numel(p.dims) == 3);
assert(isnumeric(p.vsiz) && numel(p.vsiz) == 3);

for i = 1:2:numel(varargin)
  pn = varargin{i};   % parameter name
  assert(ischar(pn), 'Parameter names must be of type char.');
  pv = varargin{i+1}; % parameter value
  switch pn
    case 'InclusionRoi'
      if islogical(pv)
        inclRoi{end+1} = pv(:);
      elseif iscell(pv) && all(cellfun(@islogical, pv))
        inclRoi = cellfun(@(x) x(:), pv, 'UniformOutput', false);
      else
        error('Unexpected type.');
      end
    case 'InclusionRoiMode'
      assert(ischar(pv) && ismember(pv, {'all', 'any', 'order'}));
      inclRoiMode = pv;
    case 'ExclusionRoi'
      assert(islogical(pv));
      if isempty(exclRoi)
        exclRoi = pv(:);
      else
        exclRoi = exclRoi | pv(:);
      end
    case 'TerminationRoi'
      assert(islogical(pv));
      assert(isempty(termRoi), 'Only one termination ROI can be specified.');
      termRoi = pv(:);
    case 'TerminationRoiMode'
      assert(ischar(pv) && ismember(pv, ...
        {'first-enter', 'first-exit', 'last-enter', 'last-exit'}));
      termRoiMode = pv;
    case 'MinPoints'
      assert(isscalar(pv) && isnumeric(pv));
      minPoints = pv;
    case 'MaxPoints'
      assert(isscalar(pv) && isnumeric(pv));
      maxPoints = pv;
    case 'MinLength'
      assert(isscalar(pv) && isnumeric(pv));
      minLength = pv;
    case 'MaxLength'
      assert(isscalar(pv) && isnumeric(pv));
      maxLength = pv;
    otherwise
      error('Unexpected parameter name.');
  end
end

assert(~(isempty(inclRoi) && isempty(exclRoi) && isempty(termRoi) ...
  && isempty(minPoints) && isempty(maxPoints) ...
  && isempty(minLength) && isempty(maxLength)), ...
  'No filtering criteria specified.');
% TODO return all input paths instead (and issue a warning)?

assert(isempty(inclRoi) || numel(inclRoi) == prod(p.dims) ...
    || (iscell(inclRoi) ...
    && all(cellfun(@(x) numel(x) == prod(p.dims), inclRoi))));
assert(isempty(exclRoi) || numel(exclRoi) == prod(p.dims));
assert(isempty(termRoi) || numel(termRoi) == prod(p.dims));

if isempty(p.paths)
  return;
end


%% filtering

% number of points
if ~isempty(minPoints) || ~isempty(maxPoints)
  disc = false(numel(p.paths), 1);
  nvox = pathProps(p, 'Points');
  if ~isempty(minPoints)                    % MinPoints
    disc = disc | (nvox < minPoints);
  end
  if ~isempty(maxPoints)                    % MaxPoints
    disc = disc | (nvox > maxPoints);
  end
  p.paths(disc) = [];
end

% length in mm
if ~isempty(minLength) || ~isempty(maxLength)
  disc = false(numel(p.paths), 1);
  len = pathProps(p, 'Length');
  if ~isempty(minLength)                    % MinLength
    disc = disc | (len < minLength);
  end
  if ~isempty(maxLength)                    % MaxLength
    disc = disc | (len > maxLength);
  end
  p.paths(disc) = [];
end

% inclusion ROIs
if ~isempty(inclRoi)
  switch inclRoiMode
    case 'all'
      for i = 1:numel(inclRoi)
        if 0
          p.paths(cellfun(@(x) ~any(inclRoi{i}(x)), p.paths)) = [];
        else
          p.paths = p.paths(mxFiltPaths(p.paths, inclRoi{i}));
        end
      end
    case 'any'
      inclRoiUnion = false(size(inclRoi{1}));
      for i = 1:numel(inclRoi)
        inclRoiUnion = inclRoiUnion | inclRoi{i};
      end
      p.paths = filtPaths(p, 'InclusionRoi', inclRoiUnion);
    case 'order'
      % TODO assert disjunct inclusion ROIs?
      p = filtPaths(p, 'InclusionRoi', inclRoi);
      if isempty(p.paths)
        return;
      end
      tmp = zeros(size(inclRoi{1}));
      for i = 1:numel(inclRoi)              % assign to each voxel
        tmp(inclRoi{i}) = i;                % the index of its comprising ROI
      end
      keep = false(numel(p),1);
      for i = 1:numel(p.paths)
        seq = tmp(p.paths{i});              % get sequence for current path
        seq(seq == 0) = [];                 % remove the unassigned
        idx = find(diff(seq) == 0);         % handle duplicates
        seq(idx + 1) = [];
        if ~isempty(...                     % pattern matching
            strfind(seq(:)', 1:numel(inclRoi)))
          keep(i) = true;
        end
      end
      p.paths = p.paths(keep);              % retain identified paths only
    otherwise
      error('Unexpected parameter value');
  end
end

% exclusion ROIs
if ~isempty(exclRoi)
  p.paths(cellfun(@(x)  any(exclRoi(x)), p.paths)) = [];
end

% termination ROI
if ~isempty(termRoi)

  idx = mxFiltPaths(p.paths, termRoi);      % first identify relevant paths
  p.paths(idx) = cellfun(@(x) trunc(x, termRoi, termRoiMode), ...
    p.paths(idx), 'UniformOutput', false);  % then truncate them

  % reapply minimum number of points, minimum length and inclusion ROI
  if ~isempty(minPoints)
    p = filtPaths(p, 'MinPoints', minPoints);
  end
  if ~isempty(minLength)
    p = filtPaths(p, 'MinLength', minLength);
  end
  if ~isempty(inclRoi) && ~isequal(termRoi, inclRoi)
    p = filtPaths(p, 'InclusionRoi', inclRoi);
  end
end


end



function p = trunc(p, roi, mode)

ind = getTruncInd(roi(p), mode);
if ~isempty(ind)
  p = p(1:ind);
end
end

function ind = getTruncInd(idx, mode)
switch mode
  case 'first-enter'
    ind = find(idx, 1);
  case 'first-exit'
    ind1 = find(idx, 1);
    ind2 = find(~idx);
    ind = ind2(find(ind2 > ind1, 1)) - 1;
  case 'last-enter'
    ind = numel(idx) - getTruncInd(flipud(idx(:)), 'first-exit') + 1;
  case 'last-exit'
    ind = numel(idx) - getTruncInd(flipud(idx(:)), 'first-enter') + 1;
  otherwise
    error('Unexpected parameter value.');
end
end
